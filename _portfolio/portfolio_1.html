---
title: "Particle Tracking Velocimetry (PTV) using K-Nearest Neighbors (KNN)"
excerpt: "A gentle, informal implementation of PTV using KNN technique using negligible mathematical equations and a pinch of Python (code)<br>
<br>
<img src='/images/KNN_/teaser.jpg'>"
collection: portfolio
---
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Code Block with Auto Syntax Highlighting</title>

    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
	
	<style> <! .... Style video container ....>
	        /* Centering the video */
        .video-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 50%;
            padding: 20px;
        }
	</style>

	<style><!....... Style the code block ....>
        /* Style for the code block container */
        .code-container {
            position: relative;
            background-color: #282c34;
            border-radius: 8px;
            padding: 15px;
            margin: 30px auto; /* Adds spacing before & after */
            max-width: 60%; /* Responsive width */
            max-height: 300px; /* Set height limit */
            overflow: auto; /* Enables horizontal & vertical scrollbars */
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);
        }

        /* Copy button */
        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #61dafb;
            color: black;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
            border-radius: 5px;
            transition: 0.3s;
        }

        .copy-btn:hover {
            background: #4fa3d1;
        }

        /* Code styling */
        pre {
            margin: 0;
            padding: 15px;
            white-space: pre; /* Prevents automatic wrapping */
            overflow: auto; /* Enables scrolling */
        }

        code {
            font-size: 16px;
        }
    </style>
</head>







<body>

```python
print( 'blbla')
```
	
		<!-------------------------- Python Code Block ----------------------->
<script>
        function copyCode(button) {
            let codeBlock = button.nextElementSibling.innerText;
            navigator.clipboard.writeText(codeBlock).then(() => {
                button.innerText = "Copied!";
                setTimeout(() => button.innerText = "Copy", 2000);
            });
        }
</script>
	<div class="code-container">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code class="language-python">
			# function to perform the Particle tracking via using KNN
			def vel_spins(frame1, frame2):
			'''
			This function uses KNN to match the particles with their image in two consecutive frames
			Params:
				frame1: preceding snapshot
				frame2: succeeding snapshot
			'''
			
			# convert the positional data from the preceding snap into correct fromat of  [xi, yi] 
			counter_frame1 = [];
			for i in range(len(frame1.values)):
				counter_frame1.append(frame1.values[i][1:])
			frame1_train_data = np.array(counter_frame1) 
			
			# convert the positional data from the succeeding snap into correct fromat of  [xi, yi]
			counter_frame2 =[];
			for i in range(len(frame2.values)):
				counter_frame2.append(frame2.values[i][1:])
			frame2_train_data = np.array(counter_frame2)
			
			# ...... Implementation of the KNN to find the nearest neighbour
			
			# instatiate the KNN model setting K =1 and the algorithm of ball tree for more efficient search
			train_data = nnbrs(n_neighbors=1, algorithm='ball_tree')
			
			# train the model using the data from the preceding SnapShot
			train_data.fit(frame1_train_data)
			
			# Use this aforementioned trained model to predict the nearest neighbour of 
			# particle position in the succeeeding frame 
			# Here we implement the logic .... the nearest neighbour will be the image of itself!!!
			
			_,indices = train_data.kneighbors(frame2_train_data) 
			# indices above provide the tags (refernce) to connect the images of the same particles between two frames 
			
			# Use the above tags to re-arrange the particle positions from the preceding frame 
			add_X = []
			add_Y = []
			for x in indices:
				add_X.append(frame1.iloc[x]['X'])
				add_Y.append(frame1.iloc[x]['Y'])
			
			# attach the rearanged particle poisitons to the positions in the final frame 
			# to create a single master coordinate table by adding to frame 2
			frame2['XX'] = np.array(add_X)
			frame2['YY'] = np.array(add_Y)  
			
			frame2['dX'] = frame2['XX'] - frame2['X']
			frame2['dY'] = frame2['YY'] - frame2['Y']
			
			# compute  ''' Displacement''' for gnerating the velocity vectors
			frame2['dR'] = np.sqrt(frame2['dX']**2 + frame2['dY']**2)
			
			# return the master table (udated frame 2) 
			return frame2 
        </code></pre>
    </div>
	
<! --------------------- Video code block --------------------------------->
	
    <video class="video-container" width = '400' height = '400' controls>
        <source src="/images/KNN_/BinaryDemixing_final.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>



</body>
